# 🌲 LeetCode 101 - 移动零

## 📘 题目描述

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

请注意 ，必须在不复制数组的情况下原地对数组进行操作。
示例 1:

输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
示例 2:

输入: nums = [0]
输出: [0]
 
提示:

1 <= nums.length <= 104
-231 <= nums[i] <= 231 - 1

## 💡 解题思路

这道题目有两个核心点：
1. 需要用到快慢指针
2. 快慢指针分别代表的含义是最重要的
3. 一个数字可以把他分成左，中，右 三个部分
    - 左边的部分为左边的已经处理过的部分（符合题目要求已经处理过的部分）
    - 中间部分是一个或者多个0组成的中间部分（因为数组中有可能有连续的0）
    - 右边部分是剩下的还需要处理的部分

4. 如果数组开始的时候是一个非零的数字，我们需要把左右指针一起往右边移动（因为左边的部分就是left 左边的部分是处理好的）
5. 核心在我看来因为左右指针一直是一起往右边移动，所以我们要知道左右指针是什么时候分开来的，然后因为左右指针中间都是0，所以要定义除非右指针不是0的时候，左右才一起移动，这样可以确保左指针指向还需要处理的第一个0那边
## 🧱 代码实现

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """

        j = 0

        for i in range(len(nums)):

            #当右指针指向非零元素的时候，此时需要和左指针指向的第一个0换位置
            if nums[i] != 0:# 此时指向一个或者多个0后的第一个非0️⃣

                if left!=right:# 这一行的意义是因为刚开始左右指针还没有分开，要等到分开的时候才换
                    nums[i], nums[j] = nums[j], nums[i]
                
                left+=1 #只有右指针非零的时候才让left 和right 一起动





