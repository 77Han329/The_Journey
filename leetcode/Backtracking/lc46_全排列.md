# å…¨æ’åˆ—

## ğŸ“– é¢˜ç›®é“¾æ¥
[LeetCode 46. Permutations](https://leetcode.com/problems/permutations/description/)


## æ€è·¯ 
å…¶å®é‡è¦çš„ä¸€ç‚¹å°±æ˜¯ç”¨ä¸€ä¸ªused æ•°ç»„æ¥è®°å½•åŒä¸€å±‚é€’å½’ä¸­ï¼ˆæ¨ªå‘å·²ç»ç”¨è¿‡çš„æ•°å­—ï¼‰ï¼Œç›¸å½“äºæˆ‘é—¨è¦å¯¹used æ•°ç»„ä¹Ÿè¿›è¡Œå›æº¯ï¼Œå› ä¸ºä¼šåœ¨åŒä¸€å±‚é‡å¤åˆ©ç”¨


## ğŸ§© ä»£ç å®ç°
```python
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        res = []
        path = []

        def backtracking(nums,used):
            if len(nums) == len(path):
                res.append(path[:])
                return
            
            for i in range(len(nums)):
                if used[i]:
                    continue
                # è¿™é‡Œæœ€é‡è¦çš„æ˜¯è¿™è¡Œä»£ç 
                """"
                é¦–å…ˆï¼Œæˆ‘ä»¬ä»¥å‰å¯ä»¥æ§åˆ¶startidx è¿™æ ·å¯ä»¥ä¸ç”¨åˆ¤æ–­æˆ‘ä»¬æ˜¯ä¸æ˜¯åœ¨åŒä¸€å±‚
                ä½†æ˜¯å› ä¸ºæ˜¯æ’åˆ—ç»„åˆï¼Œstartidx æ°¸è¿œéƒ½æ˜¯0ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦å€Ÿç”¨used æ•°ç»„æ¥åˆ¤æ–­æ˜¯ä¸æ˜¯åŒä¸€å±‚
                å› ä¸ºä¸€å±‚è‚¯å®šä¸€æ¬¡å»ä¸€ä¸ªæ•°å­—ï¼Œæˆ‘ä»¬è¦ä¸è¦ç”¨è¿™ä¸ªæ•°å­—ï¼Œé¦–å…ˆè‚¯å®šæ˜¯åˆ¤æ–­å…ƒç´ æ˜¯å¦ç›¸ç­‰
                è¿˜è¦åˆ¤æ–­æˆ‘ä»¬æ˜¯ä¸æ˜¯åœ¨è¿™ä¸€å±‚å¯¹i è¿›è¡Œæ“ä½œï¼Œå¦‚æœused[i-1]!=0 ç›¸å½“äºè¿™ä¸€å±‚æ²¡æœ‰ç”¨è¿‡ï¼Œæ‰€ä»¥å°±æ˜¯åœ¨åŒä¸€å±‚ï¼Œæ‰€ä»¥éœ€è¦åˆ¤æ–­ 
                """"
                # å…³é”®å»é‡é€»è¾‘ï¼š
                # å¯¹äºæ’åˆ—é—®é¢˜ï¼Œç”±äºæ¯å±‚é€’å½’éƒ½ä¼šä»0å¼€å§‹éå†ï¼Œæ‰€ä»¥ä¸èƒ½ç”¨ start_idx åŒºåˆ†â€œåŒä¸€å±‚â€ã€‚
                # å› æ­¤æˆ‘ä»¬ä½¿ç”¨ used æ•°ç»„æ¥åˆ¤æ–­å½“å‰æ•°å­—æ˜¯å¦åœ¨å½“å‰åˆ†æ”¯å·²ä½¿ç”¨ã€‚
                # è¿™é‡Œçš„æ¡ä»¶ if i>0 and nums[i]==nums[i-1] and not used[i-1] ç”¨äºè·³è¿‡åŒå±‚çš„é‡å¤é€‰æ‹©ï¼š
                # - å¦‚æœå‰ä¸€ä¸ªç›¸åŒæ•°å­—è¿˜æ²¡è¢«ä½¿ç”¨ (used[i-1]==0)ï¼Œè¯´æ˜å½“å‰ i ä¸ i-1 åœ¨åŒä¸€å±‚ï¼Œåº”è¯¥è·³è¿‡ï¼›
                # - å¦‚æœå‰ä¸€ä¸ªç›¸åŒæ•°å­—å·²è¢«ä½¿ç”¨ (used[i-1]==1)ï¼Œè¯´æ˜å½“å‰ i åœ¨å¦ä¸€å±‚é€’å½’ä¸­ï¼Œå¯ä»¥æ­£å¸¸ä½¿ç”¨ã€‚
                if i >0 and nums[i] == nums[i-1] and used[i-1]!=0:
                    continue 
                
                path.append(nums[i])
                used[i] = 1

                backtracking(nums,used)
                used[i] = 0
                path.pop()
        
        used = [0] * len(nums)
        backtracking(nums,used)

        return res
        

```

## ğŸ§© å‰ªæåre

        