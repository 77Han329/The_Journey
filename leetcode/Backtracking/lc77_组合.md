# 组合

## 📖 题目链接
[LeetCode 77.Combinations](https://leetcode.com/problems/combinations/)



    



## 🧩 代码实现
```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:#假设为1，2，3，4
        res =[]
        path = []

        def backtacking(self,n,k,start_idx):

            if len(path) == 2:
                res.append(path[:])
                return # 控制的是递归的深度，如果path为2了就不会往下继续递归
            
            for i in range(start_idx,n+1): # 1,2,3,4 会对4个数字进行遍历表示横向
                path.append(i)
                backtracking(n,k,i + 1) #这里是往下继续跑，12，然后会尝试123 但是长度超了，所以#弹出2 证明不能123 不能继续往下递归，然后继续递归第二层的13，然后13会尝试去第三层的134，但是长度超过了，所以返回递归14，最后1后面都完了就回去2开始往下递归
                #所以可以看出来backtracking是往下探的过程，然后有一个条件终止它的下探，for 是宽度，控制有多少数字可以用机会往下递归
                path.pop()
```

## 🧩 剪枝后re

        